
---------------------------------------------------
-- Database (tscidmdb) schema based on tsc 2.51.0
---------------------------------------------------

---------------------------------------------------------------------------
-- REMEMBER to update the metadata.sh when adding a new n-up.sql file 
---------------------------------------------------------------------------

--
-- 1. Name: ARCHIVED_OAUTH2_ACCESS_TOKENS
--

CREATE TABLE IF NOT EXISTS ARCHIVED_OAUTH2_ACCESS_TOKENS (
    OLD_REFRESH_TOKEN VARCHAR(48),
    OLD_REFRESH_TOKEN_EXPIRATION_DATES_SECONDS BIGINT,
    REFERENCE_OF_ACTIVE_REFRESH_TOKEN VARCHAR(48)
);

CREATE INDEX IF NOT EXISTS ARCHIVED_OAUTH2_ACCESS_TOKENS_OLD_REFRESH_TOKEN_IDX ON ARCHIVED_OAUTH2_ACCESS_TOKENS(OLD_REFRESH_TOKEN);

--
-- 2. Name: INITIAL_ACCESS_TOKENS
--

CREATE TABLE IF NOT EXISTS INITIAL_ACCESS_TOKENS (
    ID VARCHAR(36) NOT NULL,
    ACCESS_TOKEN VARCHAR(48),
    CREATED_BY VARCHAR(32) NOT NULL,
    CREATED_TIME BIGINT DEFAULT DATE_PART('EPOCH', CURRENT_TIMESTAMP),
    EXPIRATION_TIME BIGINT,
    TENANT_ID VARCHAR(32) NOT NULL,
    ACCOUNT_ID VARCHAR(255),
    DATAPLANE_ID VARCHAR(32),
    LAST_ACCESSED BIGINT DEFAULT 0,
    COMMENT TEXT NOT NULL,

    PRIMARY KEY (ACCESS_TOKEN)
);

-- PCP-2454 : ensure DB is indexed properly for all operations
DROP INDEX IF EXISTS INITIAL_ACCESS_TOKENS_TENANT_ID_IDX;
CREATE INDEX IF NOT EXISTS INITIAL_ACCESS_EXPIRATION_TIME_IDX ON INITIAL_ACCESS_TOKENS(EXPIRATION_TIME);
-- PCP-2899: Ensure DB is indexed properly for all operations
CREATE INDEX IF NOT EXISTS INITIAL_ACCESS_TOKENS_ID_HASH_IDX ON INITIAL_ACCESS_TOKENS USING HASH (ID);
--
-- 3. Name: NONCE
--

CREATE TABLE IF NOT EXISTS NONCE (
	NONCE VARCHAR(128) NOT NULL,
	EXPIRATION_DATES_SECONDS BIGINT NOT NULL,
	READ_VALUE BOOLEAN,
	
    PRIMARY KEY (NONCE)
);

-- PCP-2454 : ensure DB is indexed properly for all operations
CREATE INDEX IF NOT EXISTS NONCE_EXPIRATION_DATES_SECONDS_IDX ON NONCE(EXPIRATION_DATES_SECONDS);

--
-- 4. Name: OAUTH2_ACCESS_TOKENS
--

CREATE TABLE IF NOT EXISTS OAUTH2_ACCESS_TOKENS (
	ACCESS_TOKEN VARCHAR(48) NOT NULL,
	ACCESS_TOKEN_NAME VARCHAR(128),
	USER_ENTITY_ID VARCHAR(40) NOT NULL,
	LAST_ACCESSED BIGINT,
	EXPIRATION_DATES_SECONDS BIGINT DEFAULT DATE_PART('EPOCH', CURRENT_TIMESTAMP + INTERVAL '24 HOUR'),
	TENANT_ID VARCHAR(32) NOT NULL,
	JWT TEXT NOT NULL,
    AUTH_CODE VARCHAR(48),
    REFRESH_TOKEN VARCHAR(48),
    CLIENT_ID UUID,
    TSC_ACCOUNT_ID VARCHAR(56) NOT NULL DEFAULT 'DUMMY_TSC_ACCOUNT_ID',
    CREATED_DATES_SECONDS BIGINT NOT NULL DEFAULT DATE_PART('EPOCH', CURRENT_TIMESTAMP),
    REFRESH_TOKEN_EXPIRATION_DATES_SECONDS BIGINT,
    PREVIOUS_REFRESH_TOKEN VARCHAR(48),
    PREVIOUS_REFRESH_TOKEN_EXPIRATION_DATES_SECONDS BIGINT,
    SESSION_INDEX VARCHAR(48),
    REGION VARCHAR(32) NOT NULL,
    MARKED_FOR_DELETION BOOLEAN DEFAULT FALSE,

	PRIMARY KEY (ACCESS_TOKEN, USER_ENTITY_ID, TENANT_ID),
	CONSTRAINT OAUTH2_ACCESS_TOKENS_UNIQUE UNIQUE (ACCESS_TOKEN_NAME, USER_ENTITY_ID, TSC_ACCOUNT_ID, TENANT_ID, REGION)
);

-- PCP-1968: It is sorted on EXPIRATION_DATES_SECONDS using BTREE mechanism.
CREATE INDEX IF NOT EXISTS OAUTH2_ACCESS_TOKENS_EXPIRATION_DATES_SECONDS_IDX ON OAUTH2_ACCESS_TOKENS(EXPIRATION_DATES_SECONDS);
-- PCP-1968: optimize for SESSION_INDEX lookups
CREATE INDEX IF NOT EXISTS OAUTH2_ACCESS_TOKENS_SESSION_INDEX_IDX ON OAUTH2_ACCESS_TOKENS USING HASH (SESSION_INDEX);
-- PCP-2899: Ensure DB is indexed properly for all operations
CREATE INDEX IF NOT EXISTS OAUTH2_ACCESS_TOKENS_CLIENT_ID_IDX ON OAUTH2_ACCESS_TOKENS USING HASH (CLIENT_ID);

-- Create function to update active refresh token
DROP FUNCTION IF EXISTS REFRESH_TOKEN_UPDATED() CASCADE;
CREATE FUNCTION REFRESH_TOKEN_UPDATED()
RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
    -- If new REFRESH_TOKEN is generated add in ARCHIVED_OAUTH2_ACCESS_TOKENS table only if row doesn't exist
    IF NEW.PREVIOUS_REFRESH_TOKEN IS NOT NULL THEN
        IF NOT EXISTS(SELECT * FROM ARCHIVED_OAUTH2_ACCESS_TOKENS WHERE OLD_REFRESH_TOKEN = NEW.PREVIOUS_REFRESH_TOKEN 
            AND REFERENCE_OF_ACTIVE_REFRESH_TOKEN = NEW.REFRESH_TOKEN) THEN
            
            INSERT INTO ARCHIVED_OAUTH2_ACCESS_TOKENS (OLD_REFRESH_TOKEN, OLD_REFRESH_TOKEN_EXPIRATION_DATES_SECONDS, REFERENCE_OF_ACTIVE_REFRESH_TOKEN)
            VALUES (NEW.PREVIOUS_REFRESH_TOKEN, NEW.PREVIOUS_REFRESH_TOKEN_EXPIRATION_DATES_SECONDS, NEW.REFRESH_TOKEN);
        END IF;

        -- Update REFRENCE_REFRESH_TOKEN with new REFRESH_TOKEN for all rows
        UPDATE ARCHIVED_OAUTH2_ACCESS_TOKENS SET REFERENCE_OF_ACTIVE_REFRESH_TOKEN = NEW.REFRESH_TOKEN WHERE REFERENCE_OF_ACTIVE_REFRESH_TOKEN = NEW.PREVIOUS_REFRESH_TOKEN;

        -- Delete old ACCESSTOKEN and REFRESH_TOKEN
        DELETE FROM OAUTH2_ACCESS_TOKENS WHERE REFRESH_TOKEN = NEW.PREVIOUS_REFRESH_TOKEN;
    END IF;
    
    RETURN NEW; 
END $$;

DROP TRIGGER IF EXISTS REFRESH_TOKEN_UPDATED_TRIGGER ON OAUTH2_ACCESS_TOKENS;
CREATE TRIGGER REFRESH_TOKEN_UPDATED_TRIGGER 
    BEFORE INSERT ON OAUTH2_ACCESS_TOKENS 
    FOR EACH ROW 
    EXECUTE PROCEDURE REFRESH_TOKEN_UPDATED();




--
-- 5. Name: OAUTH2_AUTH_CODES
--

CREATE TABLE IF NOT EXISTS OAUTH2_AUTH_CODES (
	AUTH_CODE VARCHAR(48) NOT NULL,
	CLIENT_ID VARCHAR(128) NOT NULL,
	OPAQUE_STATE TEXT,
	CODE_CHALLENGE VARCHAR(64),
	REDIRECT_URI VARCHAR(512),
	EXPIRATION_DATES_SECONDS BIGINT,
	OAUTH_SCOPE VARCHAR(128),
    TENANTS_JWT TEXT,
    NONCE VARCHAR(128)
);

-- PCP-2454 : ensure DB is indexed properly for all operations
CREATE INDEX IF NOT EXISTS OAUTH2_AUTH_CODES_AUTH_CODE_IDX ON OAUTH2_AUTH_CODES USING HASH (AUTH_CODE);

--
-- 6. Name: OAUTH2_CLIENTS
--

CREATE TABLE IF NOT EXISTS OAUTH2_CLIENTS (
	CLIENT_ID UUID NOT NULL DEFAULT UUID_GENERATE_V4(),
	CLIENT_NAME VARCHAR(128),
	JWKS_URL VARCHAR(255),
	ISSUER VARCHAR(255),
	TSC_ACCOUNT_ID VARCHAR(56),
	CREATED_BY VARCHAR(56) NOT NULL,
	CREATED_TIME BIGINT,
    REDIRECT_URIS VARCHAR(255) ARRAY,
    OTHER_ATTRIBUTES JSON NOT NULL DEFAULT '{}',
    LAST_ACCESSED BIGINT NOT NULL DEFAULT 0,
    CLIENT_SECRET VARCHAR(64),
    CLIENT_SECRET_EXPIRES_AT BIGINT,
    CLIENT_TYPE VARCHAR(48) NOT NULL,
	REGISTRATION_ACCESS_TOKEN VARCHAR(64),
	
	PRIMARY KEY (CLIENT_ID),
	UNIQUE (CLIENT_NAME, TSC_ACCOUNT_ID)
);

-- PCP-1968: ensure we have hash index for TSC_ACCOUNT_ID and delete the old index OAUTH2_CLIENTS_TSC_ACCOUNT_ID_IDX
-- and create new using hash for TSC_ACCOUNT_ID and CREATED_BY
CREATE INDEX IF NOT EXISTS OAUTH2_CLIENTS_TSC_ACCOUNT_ID_HASH_IDX ON OAUTH2_CLIENTS USING HASH (TSC_ACCOUNT_ID);
DROP INDEX IF EXISTS OAUTH2_CLIENTS_TSC_ACCOUNT_ID_IDX;
-- PCP-1968: fast lookups by CREATED_BY
CREATE INDEX IF NOT EXISTS OAUTH2_CLIENTS_CREATED_BY_IDX ON OAUTH2_CLIENTS USING HASH (CREATED_BY);

--
-- 7. Name: OAUTH2_USER_CONSENTS
--

CREATE TABLE IF NOT EXISTS OAUTH2_USER_CONSENTS (
	TSC_ACCOUNT_ID VARCHAR(32) NOT NULL,
	USER_ENTITY_ID VARCHAR(32) NOT NULL,
	CLIENT_ID UUID NOT NULL,
	SCOPE VARCHAR(32) NOT NULL,
	REGION VARCHAR(32) NOT NULL,
	TIMESTAMP BIGINT DEFAULT DATE_PART('EPOCH', CURRENT_TIMESTAMP),
    REDIRECT_URIS VARCHAR(255) ARRAY NOT NULL,

	PRIMARY KEY (TSC_ACCOUNT_ID, USER_ENTITY_ID, CLIENT_ID, SCOPE, REGION),
	FOREIGN KEY (CLIENT_ID) REFERENCES OAUTH2_CLIENTS(CLIENT_ID) ON DELETE CASCADE
);

-- PCP-2899: Ensure DB is indexed properly for all operations
CREATE INDEX IF NOT EXISTS OAUTH2_USER_CONSENTS_TSC_ACCOUNT_ID_HASH_IDX ON OAUTH2_USER_CONSENTS USING HASH (TSC_ACCOUNT_ID);
CREATE INDEX IF NOT EXISTS OAUTH2_USER_CONSENTS_CLIENT_ID_IDX ON OAUTH2_USER_CONSENTS USING HASH (CLIENT_ID);

-- CPS:924 Update all rows to upper case for column scope in OAUTH2_USER_CONSENTS table
UPDATE OAUTH2_USER_CONSENTS SET SCOPE = UPPER(SCOPE);

-- Function to validate REDIRECT_URI
DROP FUNCTION IF EXISTS VALIDATE_REDIRECT_URI_TRIGGER() CASCADE;
CREATE FUNCTION VALIDATE_REDIRECT_URI_TRIGGER()
RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
	PERFORM CLIENT_ID FROM OAUTH2_CLIENTS
    WHERE CLIENT_ID = NEW.CLIENT_ID
    AND OAUTH2_CLIENTS.REDIRECT_URIS @> NEW.REDIRECT_URIS;

	IF NOT FOUND THEN
		RAISE EXCEPTION 'ILLEGAL REDIRECT_URI';
	END IF;
	RETURN NEW;
END $$;

-- CREATE TRIGGER to validate REDIRECT_URI before adding new row in OAUTH2_USER_CONSENTS table
DROP TRIGGER IF EXISTS VALIDATE_REDIRECT_URI_TRIGGER ON OAUTH2_USER_CONSENTS;
CREATE TRIGGER VALIDATE_REDIRECT_URI_TRIGGER BEFORE INSERT ON OAUTH2_USER_CONSENTS FOR EACH ROW EXECUTE PROCEDURE VALIDATE_REDIRECT_URI_TRIGGER();

-- Function to validate DELETE_EMPTY_REDIRECT_URIS_ROW
DROP FUNCTION IF EXISTS DELETE_EMPTY_REDIRECT_URIS_ROW() CASCADE;
CREATE FUNCTION DELETE_EMPTY_REDIRECT_URIS_ROW()
RETURNS TRIGGER LANGUAGE PLPGSQL AS $$
BEGIN
	DELETE FROM OAUTH2_USER_CONSENTS WHERE REDIRECT_URIS = '{}';
	-- TRIGGER added AFTER UPDATE so the RETURN value is not used, hence return 'NULL'
	RETURN NULL;

END $$;

-- CREATE TRIGGER to validate REDIRECT_URI before adding new row in OAUTH2_USER_CONSENTS table
DROP TRIGGER IF EXISTS DELETE_EMPTY_REDIRECT_URIS_ROW_TRIGGER ON OAUTH2_USER_CONSENTS;
CREATE TRIGGER DELETE_EMPTY_REDIRECT_URIS_ROW_TRIGGER AFTER UPDATE ON OAUTH2_USER_CONSENTS FOR EACH ROW EXECUTE PROCEDURE DELETE_EMPTY_REDIRECT_URIS_ROW();

-- CREATE ENUM FOR IDP_TYPE
DO $$ BEGIN
    CREATE TYPE IDP_TYPE AS ENUM ('SAML', 'Google', 'OIDC');
EXCEPTION
    WHEN DUPLICATE_OBJECT THEN
		RAISE NOTICE 'type IDP_TYPE exists, hence skipping...';
END $$;


-- PCP-883: Add ACCOUNT_ID and DATAPLANE_ID in INITIAL_ACCESS_TOKENS table and change length of USER_ENTITY_ID to 40 in OAUTH2_ACCESS_TOKENS table
ALTER TABLE INITIAL_ACCESS_TOKENS
    ADD COLUMN IF NOT EXISTS ACCOUNT_ID VARCHAR(255),
    ADD COLUMN IF NOT EXISTS DATAPLANE_ID VARCHAR(32);

ALTER TABLE OAUTH2_ACCESS_TOKENS
    ALTER COLUMN USER_ENTITY_ID TYPE VARCHAR(40);


-- CREATE ENUM FOR IDP STATUS
DO $$ BEGIN
    CREATE TYPE STATUS AS ENUM ('REQUESTED', 'CONFIGURED', 'ENABLED');
EXCEPTION
    WHEN DUPLICATE_OBJECT THEN
		RAISE NOTICE 'type STATUS exists, hence skipping...';
END $$;

--
-- 8. Name: IDP_DETAILS
--

CREATE TABLE IF NOT EXISTS IDP_DETAILS (
    ACCOUNT_ID VARCHAR(56) NOT NULL,
    PREFIX_ID VARCHAR(8) NOT NULL,
    HOST_PREFIX VARCHAR(24) NOT NULL,
    IDP_TYPE IDP_TYPE NOT NULL,
    STATUS  STATUS  DEFAULT 'REQUESTED',
    METADATA JSON NOT NULL DEFAULT '{}',
    KNOWN_GROUPS VARCHAR(24)[],
    UPDATED_ON TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ENABLED_ON TIMESTAMP WITH TIME ZONE,
    COMMENT VARCHAR(256) NOT NULL,

    PRIMARY KEY (ACCOUNT_ID, PREFIX_ID)
);

ALTER TABLE IDP_DETAILS ADD COLUMN IF NOT EXISTS REQUESTED_BY VARCHAR(40) NOT NULL DEFAULT 'Default REQUESTED_BY';
ALTER TABLE IDP_DETAILS ALTER COLUMN HOST_PREFIX TYPE VARCHAR(32);
ALTER TABLE IDP_DETAILS ALTER COLUMN KNOWN_GROUPS TYPE VARCHAR(48)[];

CREATE INDEX IF NOT EXISTS HOST_PREFIX_IDX ON IDP_DETAILS USING HASH (HOST_PREFIX);

--
-- 9. Name: SCHEMA_VERSION
--


CREATE TABLE IF NOT EXISTS SCHEMA_VERSION (
	ID SERIAL PRIMARY KEY,
	VERSION INTEGER NOT NULL,

	CONSTRAINT SCHEMA_VERSION_UNIQUE_CONSTRAINT UNIQUE (VERSION)
);

INSERT INTO SCHEMA_VERSION (VERSION) VALUES (1) ON CONFLICT DO NOTHING;
